
class Rules:

    def constr() -> None:
        int rule_born = 3
        int rule_life = 2 or 3

class Scen:
    def constr() -> None:
        int size_window = ()
        int size_edge = () 
        color life_edge = ()
        color dead_edge = ()


class Verb:

  Verb()    Verb()  Verb()
      |  \    |      /  \
   Verb()   -  verb() - Verb()
       |   /       |   \ /
   Verb()    Verb()  Verb()
  

class Colony(): 
 Это набор связаных между собой ячеек.
Как хранить такой объем данных? Насколько большой он должен быть?
Должен быть динамическим!

Есть матрица в каждой ячейке есть ссылка на "Жизнь", если ссылка пустая то там нет жизни.
"Жизнь" это класс типа графа где храняться ссылка на другие "Жизни" и мертвые клетки.
Каждая "Жизнь" имеет ссылкан на "Еву"
У каждой жизни есть ссылки на мертвые клетки.
Каждая мертвая ссылка имеет ссылка на 8й клетки , если мертвая клетка имеет вокруг себя только мертвые клетки - они в память не попадает и алгоритм создания не продолжает работать

Клетка имеет два статуса
текущий статус 
последующий статус

Например статус жива, но после поправил будет на следующим шаге мертва
Старт
создать "мир"
заполнить поле клетками случайно
запустить такт
Такт 
- порверить окончание жизни
- проверить состояние ячеек и по правил их изменить
- применить состояние ячеек в действие. т.е умирают и рождаютья одновременно
- отобразить изменения на экране
- повторить такт

Классы:
Life
Eva
Net
Word 

Eve.create_life(i,j) => Life {
    life = _create()
    return life
}

Eva.add(life) => Life {
    """
    Добавить клетку
        - добавить Клетку в хранилище живых - Ева
        - добавить ссылку на Клетку в Мир по координатно 
        - соединить соседями
            - поиск соседей вокруг клетки
                - если в ячейке есть клетка, то добавить связь
    """

    add_to_storage(life)
    add_to_word(life)
    new_life = update_net(life)
    return new_life
}

Eva.delete(life) => None {
    """    
    Умертвить клетку
        - Удалить ссылку из Мира по координатам
        - Удалить связи с клетками
        - Удалить Клетку из хранилища 
    """

    delete_life_from_word(life)
    delete_net(life)
    remove_from_storage(life)
}

Eva.check_colony(lifes: list) => None {
    """
        Проврка стостояния живых клеток
            - Обойти хранилище живых клеток
                - если чилсо связей rule_life , то сохранить статус жизнь, иначе выставить статус смерть
    """
    for life in lifes:
        if life.get_count_net() != eva.rule_life then
            life.set_status(Die)
}

Eva.find_new_life(lifes: list) => List {
"""
Проверка состояния мертвых клеток (поиск мест создания Клеток)
    - Получить список живых Клеток от Евы
    - Обойти все живых клеток 
        - Клетка имеет две связности, то запуска обхода ячеек вокруг Клетки
            - Обхода ячеек вокруг Клетки:
                - Если ячейка мертвая, то запуск обхада всех ячеек вокруг него 
                    - обхадим все ячеек вокруг мертвой: 
                        - Если ячейка живая, то увеличить счетчик живых Клеток на 1
                    - Если счетчик будет равный 3, то в ячееку добвляем Клетку в эту ячейку
"""
    for life in lifes:
        if life.get_count_net() == 2:
            this.loop_around(life) {
                for cell in this.loop(life.pos()):
                    if cell.status is Dead:
                        count_life = 0
                        for cell in this.loop(cell.pos())
                            if cell.status if Life:
                                count_life += 1
                        if count_life == 3 :
                            this.create_life(cell.pos())
            }

}


(!) Идея:
Если при добавления клетки вокруг мертвые увеличиваю значени на единцу связности с живой
Если добавить Клетку на уже связанную с чем-то мертвую ячейку, то просто заново пройтись

Что если разделить тип объектов
- ячейка - пустая клетка в поле
- мертвая клетка - появляются вокруг живой клетки
- живая клетка


